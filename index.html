<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Quantum Trading Bot - Análise Avançada</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-chart-financial"></script>
  <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/technicalindicators/dist/technicalindicators.min.js"></script>
  <!-- Adapter para resolver o erro de data -->
  <script src="https://cdn.jsdelivr.net/npm/date-fns@2.29.3/date_fns.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <style>
    :root {
      --primary: #0f172a;
      --secondary: #1e293b;
      --accent: #3b82f6;
      --positive: #10b981;
      --negative: #ef4444;
      --warning: #f59e0b;
      --text: #f1f5f9;
      --text-secondary: #94a3b8;
      --support: rgba(16, 185, 129, 0.15);
      --resistance: rgba(239, 68, 68, 0.15);
      --pattern: rgba(139, 92, 246, 0.15);
      --bollinger: rgba(245, 158, 11, 0.15);
      --ichimoku: rgba(101, 163, 13, 0.15);
    }
    
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
    }
    
    body {
      background: var(--primary);
      color: var(--text);
      line-height: 1.6;
      min-height: 100vh;
      overflow-x: hidden;
    }
    
    .container {
      max-width: 1800px;
      margin: 0 auto;
      padding: 20px;
      display: grid;
      grid-template-columns: 300px 1fr;
      gap: 20px;
    }
    
    @media (max-width: 1200px) {
      .container {
        grid-template-columns: 1fr;
      }
    }
    
    /* Sidebar */
    .sidebar {
      background: var(--secondary);
      border-radius: 16px;
      padding: 25px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
      display: flex;
      flex-direction: column;
      gap: 20px;
    }
    
    .logo {
      display: flex;
      align-items: center;
      gap: 12px;
    }
    
    .logo h1 {
      font-size: 1.8rem;
      background: linear-gradient(90deg, #3b82f6, #8b5cf6);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }
    
    .status-card {
      background: rgba(30, 41, 59, 0.7);
      border-radius: 12px;
      padding: 20px;
      border-left: 4px solid var(--accent);
    }
    
    .status-indicator {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 15px;
    }
    
    .indicator {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background: var(--negative);
      box-shadow: 0 0 10px var(--negative);
    }
    
    .indicator.active {
      background: var(--positive);
      box-shadow: 0 0 10px var(--positive);
    }
    
    .control-panel {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    
    .btn {
      background: var(--accent);
      color: white;
      border: none;
      padding: 12px;
      border-radius: 12px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
      display: flex;
      align-items: center;
      gap: 10px;
      text-align: left;
    }
    
    .btn i {
      font-size: 1.2rem;
    }
    
    .btn:hover {
      opacity: 0.9;
      transform: translateY(-2px);
    }
    
    .btn-stop {
      background: var(--negative);
    }
    
    .notification-panel {
      background: rgba(30, 41, 59, 0.7);
      border-radius: 12px;
      padding: 20px;
      flex-grow: 1;
      display: flex;
      flex-direction: column;
    }
    
    .notification-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
    }
    
    .notification-list {
      flex-grow: 1;
      overflow-y: auto;
      max-height: 300px;
    }
    
    .notification-item {
      padding: 12px;
      border-radius: 8px;
      background: rgba(30, 41, 59, 0.5);
      margin-bottom: 10px;
      border-left: 3px solid var(--accent);
    }
    
    .notification-item.buy {
      border-left-color: var(--positive);
    }
    
    .notification-item.sell {
      border-left-color: var(--negative);
    }
    
    .notification-time {
      font-size: 0.8rem;
      color: var(--text-secondary);
      margin-top: 5px;
    }
    
    /* Main Content */
    .main-content {
      display: flex;
      flex-direction: column;
      gap: 20px;
    }
    
    .dashboard-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
    }
    
    .timeframe-selector {
      display: flex;
      background: var(--secondary);
      border-radius: 12px;
      padding: 4px;
    }
    
    .timeframe-btn {
      padding: 8px 16px;
      border-radius: 8px;
      cursor: pointer;
      font-weight: 500;
      transition: all 0.3s ease;
    }
    
    .timeframe-btn.active {
      background: var(--accent);
    }
    
    .card-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
      gap: 20px;
      margin-bottom: 20px;
    }
    
    .card {
      background: var(--secondary);
      border-radius: 16px;
      padding: 25px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
    }
    
    .card-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
    }
    
    .card-title {
      font-size: 1.2rem;
      font-weight: 600;
      color: var(--text);
      display: flex;
      align-items: center;
      gap: 10px;
    }
    
    .chart-container {
      height: 300px;
      margin-top: 15px;
      position: relative;
    }
    
    .chart-container-large {
      height: 400px;
    }
    
    .chart-annotations {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 10;
    }
    
    .support-line {
      position: absolute;
      left: 0;
      right: 0;
      height: 2px;
      background: var(--positive);
      opacity: 0.7;
    }
    
    .resistance-line {
      position: absolute;
      left: 0;
      right: 0;
      height: 2px;
      background: var(--negative);
      opacity: 0.7;
    }
    
    .pattern-indicator {
      position: absolute;
      background: rgba(139, 92, 246, 0.2);
      border: 1px solid #8b5cf6;
      border-radius: 4px;
      padding: 4px 8px;
      font-size: 0.8rem;
      font-weight: 600;
    }
    
    .signal-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
      gap: 20px;
    }
    
    .signal-card {
      background: var(--secondary);
      border-radius: 16px;
      overflow: hidden;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
      border-top: 4px solid var(--accent);
      transition: transform 0.3s ease;
    }
    
    .signal-card.buy {
      border-top-color: var(--positive);
    }
    
    .signal-card.sell {
      border-top-color: var(--negative);
    }
    
    .signal-card:hover {
      transform: translateY(-5px);
    }
    
    .signal-header {
      padding: 20px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: rgba(30, 41, 59, 0.5);
    }
    
    .signal-type {
      font-size: 1.1rem;
      font-weight: 700;
      text-transform: uppercase;
    }
    
    .signal-buy {
      color: var(--positive);
    }
    
    .signal-sell {
      color: var(--negative);
    }
    
    .signal-time {
      color: var(--text-secondary);
      font-size: 0.9rem;
    }
    
    .signal-body {
      padding: 20px;
    }
    
    .signal-info {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 15px;
      margin-bottom: 20px;
    }
    
    .info-item {
      display: flex;
      flex-direction: column;
    }
    
    .info-label {
      color: var(--text-secondary);
      font-size: 0.9rem;
      margin-bottom: 5px;
    }
    
    .info-value {
      font-size: 1.1rem;
      font-weight: 600;
    }
    
    .pattern-container {
      background: var(--pattern);
      border-radius: 12px;
      padding: 15px;
      margin-top: 15px;
      border: 1px solid #8b5cf6;
    }
    
    .pattern-title {
      color: #8b5cf6;
      font-weight: 600;
      margin-bottom: 8px;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .pattern-description {
      font-size: 0.9rem;
      margin-top: 8px;
    }
    
    .pattern-badge {
      display: inline-block;
      padding: 4px 10px;
      border-radius: 20px;
      font-size: 0.8rem;
      font-weight: 600;
      background: rgba(139, 92, 246, 0.3);
      color: #8b5cf6;
      margin-top: 5px;
    }
    
    .pattern-badge.continuation {
      background: rgba(16, 185, 129, 0.3);
      color: var(--positive);
    }
    
    .pattern-badge.reversal {
      background: rgba(239, 68, 68, 0.3);
      color: var(--negative);
    }
    
    .levels-container {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 15px;
      margin-top: 15px;
    }
    
    .level-card {
      border-radius: 12px;
      padding: 15px;
    }
    
    .support-card {
      background: var(--support);
      border: 1px solid var(--positive);
    }
    
    .resistance-card {
      background: var(--resistance);
      border: 1px solid var(--negative);
    }
    
    .level-title {
      font-weight: 600;
      margin-bottom: 10px;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .support-title {
      color: var(--positive);
    }
    
    .resistance-title {
      color: var(--negative);
    }
    
    .level-list {
      list-style: none;
    }
    
    .level-list li {
      padding: 5px 0;
      display: flex;
      justify-content: space-between;
    }
    
    .level-list li:not(:last-child) {
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }
    
    .stat-badge {
      padding: 4px 10px;
      border-radius: 20px;
      font-size: 0.8rem;
      font-weight: 600;
    }
    
    .stat-positive {
      background: rgba(16, 185, 129, 0.2);
      color: var(--positive);
    }
    
    .stat-negative {
      background: rgba(239, 68, 68, 0.2);
      color: var(--negative);
    }
    
    .stat-neutral {
      background: rgba(100, 116, 139, 0.2);
      color: var(--text-secondary);
    }
    
    .notification-badge {
      position: absolute;
      top: -8px;
      right: -8px;
      background: var(--negative);
      color: white;
      border-radius: 50%;
      width: 20px;
      height: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.7rem;
      font-weight: bold;
    }
    
    .loading {
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100%;
      color: var(--accent);
      font-size: 1.2rem;
    }
    
    .loading i {
      margin-right: 10px;
      animation: spin 2s linear infinite;
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    .symbol-selector {
      background: var(--secondary);
      border-radius: 12px;
      padding: 8px;
      font-size: 1rem;
      color: var(--text);
      border: 1px solid rgba(100, 116, 139, 0.5);
    }
    
    .indicators-summary {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 15px;
      margin-top: 20px;
    }
    
    .indicator-card {
      background: rgba(30, 41, 59, 0.5);
      border-radius: 12px;
      padding: 15px;
      text-align: center;
    }
    
    .indicator-title {
      font-size: 0.9rem;
      color: var(--text-secondary);
      margin-bottom: 5px;
    }
    
    .indicator-value {
      font-size: 1.2rem;
      font-weight: 700;
    }
    
    .indicator-positive {
      color: var(--positive);
    }
    
    .indicator-negative {
      color: var(--negative);
    }
    
    .indicator-neutral {
      color: var(--accent);
    }
    
    .indicator-description {
      font-size: 0.8rem;
      margin-top: 5px;
      color: var(--text-secondary);
    }
    
    .tabs {
      display: flex;
      gap: 10px;
      margin-bottom: 15px;
    }
    
    .tab {
      padding: 8px 16px;
      border-radius: 8px;
      background: rgba(30, 41, 59, 0.5);
      cursor: pointer;
      transition: all 0.3s ease;
    }
    
    .tab.active {
      background: var(--accent);
    }
    
    .trend-direction {
      display: inline-flex;
      align-items: center;
      padding: 4px 10px;
      border-radius: 20px;
      font-size: 0.9rem;
      font-weight: 600;
    }
    
    .trend-up {
      background: rgba(16, 185, 129, 0.2);
      color: var(--positive);
    }
    
    .trend-down {
      background: rgba(239, 68, 68, 0.2);
      color: var(--negative);
    }
    
    .trend-neutral {
      background: rgba(100, 116, 139, 0.2);
      color: var(--text-secondary);
    }
  </style>
</head>
<body>
  <div class="container">
    <!-- Sidebar -->
    <div class="sidebar">
      <div class="logo">
        <i class="fas fa-robot"></i>
        <h1>Quantum Bot</h1>
      </div>
      
      <div class="status-card">
        <div class="status-indicator">
          <div class="indicator active" id="statusIndicator"></div>
          <span id="statusText">Sistema Ativo</span>
        </div>
        <div class="control-panel">
          <button id="toggleBot" class="btn btn-stop">
            <i class="fas fa-power-off"></i>
            Parar Sistema
          </button>
          <button class="btn">
            <i class="fas fa-bell"></i>
            Configurar Notificações
            <span class="notification-badge">3</span>
          </button>
          <button class="btn">
            <i class="fas fa-cog"></i>
            Configurações Avançadas
          </button>
        </div>
      </div>
      
      <div class="notification-panel">
        <div class="notification-header">
          <h3>Notificações</h3>
          <button class="btn" style="padding: 6px 10px; font-size: 0.9rem;" id="refreshNotifications">
            <i class="fas fa-sync-alt"></i>
          </button>
        </div>
        <div class="notification-list" id="notificationList">
          <div class="notification-item buy">
            <strong>COMPRA: BTC/USDT</strong>
            <p>Carregando dados em tempo real...</p>
            <div class="notification-time">--:--:--</div>
          </div>
        </div>
      </div>
    </div>
    
    <!-- Main Content -->
    <div class="main-content">
      <div class="dashboard-header">
        <div class="timeframe-selector" id="timeframeSelector">
          <div class="timeframe-btn" data-tf="1m">M1</div>
          <div class="timeframe-btn active" data-tf="5m">M5</div>
          <div class="timeframe-btn" data-tf="15m">M15</div>
          <div class="timeframe-btn" data-tf="1h">H1</div>
          <div class="timeframe-btn" data-tf="4h">H4</div>
        </div>
        <div>
          <select id="symbolSelector" class="symbol-selector">
            <option value="BTCUSDT">BTC/USDT</option>
            <option value="ETHUSDT">ETH/USDT</option>
            <option value="SOLUSDT">SOL/USDT</option>
            <option value="XRPUSDT">XRP/USDT</option>
            <option value="ADAUSDT">ADA/USDT</option>
          </select>
          <span class="stat-badge stat-positive" id="accuracyBadge">Precisão: 78.5%</span>
        </div>
      </div>
      
      <div class="card">
        <div class="card-header">
          <h2 class="card-title"><i class="fas fa-chart-line"></i> Análise de Preço - <span id="chartSymbol">BTC/USDT</span></h2>
          <div class="tabs">
            <div class="tab active" data-chart="price">Preço</div>
            <div class="tab" data-chart="indicators">Indicadores</div>
          </div>
        </div>
        <div class="chart-container chart-container-large">
          <canvas id="priceChart"></canvas>
          <div class="chart-annotations" id="chartAnnotations"></div>
        </div>
      </div>
      
      <div class="card-grid">
        <div class="card">
          <div class="card-header">
            <h2 class="card-title"><i class="fas fa-ruler-combined"></i> Níveis de Suporte/Resistência</h2>
          </div>
          <div class="levels-container">
            <div class="level-card support-card">
              <div class="level-title support-title">
                <i class="fas fa-arrow-up"></i>
                Suportes Fortes
              </div>
              <ul class="level-list" id="supportList">
                <li>Carregando dados...</li>
              </ul>
            </div>
            
            <div class="level-card resistance-card">
              <div class="level-title resistance-title">
                <i class="fas fa-arrow-down"></i>
                Resistências Fortes
              </div>
              <ul class="level-list" id="resistanceList">
                <li>Carregando dados...</li>
              </ul>
            </div>
          </div>
        </div>
        
        <div class="card">
          <div class="card-header">
            <h2 class="card-title"><i class="fas fa-chart-bar"></i> Resumo de Indicadores</h2>
          </div>
          <div class="indicators-summary" id="indicatorsSummary">
            <!-- Indicators will be loaded dynamically -->
            <div class="loading">
              <i class="fas fa-circle-notch"></i> Calculando indicadores...
            </div>
          </div>
        </div>
      </div>
      
      <div class="card">
        <div class="card-header">
          <h2 class="card-title"><i class="fas fa-shapes"></i> Padrões Gráficos Identificados</h2>
        </div>
        <div class="signal-grid" id="patternsGrid">
          <!-- Patterns will be loaded dynamically -->
          <div class="loading">
            <i class="fas fa-circle-notch"></i> Analisando padrões gráficos...
          </div>
        </div>
      </div>
      
      <div class="card">
        <div class="card-header">
          <h2 class="card-title"><i class="fas fa-bell"></i> Sinais em Tempo Real</h2>
        </div>
        <div class="signal-grid" id="signalsGrid">
          <!-- Signals will be loaded dynamically -->
          <div class="loading">
            <i class="fas fa-circle-notch"></i> Monitorando sinais de mercado...
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // Configurações globais
    const config = {
      symbol: 'BTCUSDT',
      timeframe: '5m',
      chart: null,
      rsiPeriod: 14,
      bollingerPeriod: 20,
      bollingerDeviation: 2,
      stochasticPeriod: 14,
      stochasticSignalPeriod: 3,
      adxPeriod: 14,
      atrPeriod: 14,
      macdConfig: {
        fastPeriod: 12,
        slowPeriod: 26,
        signalPeriod: 9,
        SimpleMAOscillator: false,
        SimpleMASignal: false
      },
      supportResistancePeriod: 50
    };
    
    // Elementos DOM
    const elements = {
      priceChart: document.getElementById('priceChart'),
      notificationList: document.getElementById('notificationList'),
      statusIndicator: document.getElementById('statusIndicator'),
      statusText: document.getElementById('statusText'),
      toggleBot: document.getElementById('toggleBot'),
      chartAnnotations: document.getElementById('chartAnnotations'),
      chartSymbol: document.getElementById('chartSymbol'),
      supportList: document.getElementById('supportList'),
      resistanceList: document.getElementById('resistanceList'),
      patternsGrid: document.getElementById('patternsGrid'),
      signalsGrid: document.getElementById('signalsGrid'),
      timeframeSelector: document.getElementById('timeframeSelector'),
      symbolSelector: document.getElementById('symbolSelector'),
      accuracyBadge: document.getElementById('accuracyBadge'),
      refreshNotifications: document.getElementById('refreshNotifications'),
      indicatorsSummary: document.getElementById('indicatorsSummary'),
      tabs: document.querySelectorAll('.tab')
    };
    
    // Dados de mercado
    let marketData = {
      klines: [],
      indicators: {
        rsi: [],
        macd: {macd: 0, signal: 0, histogram: 0},
        bollinger: {upper: [], middle: [], lower: []},
        stochastic: {k: [], d: []},
        volume: [],
        adx: [],
        atr: [],
        sar: [],
        obv: [],
        fibRetracement: []
      },
      patterns: [],
      signals: [],
      supportLevels: [],
      resistanceLevels: []
    };
    
    // Padrões gráficos predefinidos
    const chartPatterns = [
      {
        name: "Bandeira de Alta",
        type: "continuation",
        confidence: 85,
        description: "Padrão de continuação que se forma após um movimento forte de alta. Indica uma pausa no movimento antes da continuação da tendência.",
        icon: "fas fa-flag"
      },
      {
        name: "Cabeça e Ombros",
        type: "reversal",
        confidence: 78,
        description: "Padrão de reversão caracterizado por três picos, sendo o do meio o mais alto. Sinaliza uma possível reversão de tendência de alta para baixa.",
        icon: "fas fa-chart-line"
      },
      {
        name: "Martelo",
        type: "reversal",
        confidence: 92,
        description: "Padrão de reversão de baixa que ocorre no final de uma tendência de queda. Caracteriza-se por um pequeno corpo e uma longa sombra inferior.",
        icon: "fas fa-hammer"
      },
      {
        name: "Triângulo Ascendente",
        type: "continuation",
        confidence: 80,
        description: "Padrão de continuação de alta caracterizado por uma linha de resistência horizontal e uma linha de suporte ascendente.",
        icon: "fas fa-chart-area"
      },
      {
        name: "Estrela da Manhã",
        type: "reversal",
        confidence: 88,
        description: "Padrão de reversão de alta composto por três velas: uma grande negativa, uma pequena e uma grande positiva.",
        icon: "fas fa-star"
      }
    ];
    
    // Buscar dados históricos da Binance
    async function fetchMarketData() {
      try {
        const response = await axios.get(`https://api.binance.com/api/v3/klines`, {
          params: {
            symbol: config.symbol,
            interval: config.timeframe,
            limit: 100
          }
        });
        
        // Processar dados
        marketData.klines = response.data.map(k => ({
          time: new Date(k[0]),
          open: parseFloat(k[1]),
          high: parseFloat(k[2]),
          low: parseFloat(k[3]),
          close: parseFloat(k[4]),
          volume: parseFloat(k[5])
        }));
        
        // Atualizar indicadores
        calculateIndicators();
        
        // Identificar padrões
        identifyPatterns();
        
        // Identificar suportes e resistências
        identifySupportResistance();
        
        // Atualizar gráfico
        updateChart();
        
        // Atualizar UI
        updateUI();
        
      } catch (error) {
        console.error('Erro ao buscar dados:', error);
        showNotification('', 'Erro', `Falha ao buscar dados: ${error.message}`);
      }
    }
    
    // Calcular indicadores técnicos
    function calculateIndicators() {
      const closes = marketData.klines.map(k => k.close);
      const highs = marketData.klines.map(k => k.high);
      const lows = marketData.klines.map(k => k.low);
      const volumes = marketData.klines.map(k => k.volume);
      
      // Calcular RSI
      if (typeof window.technicalIndicators !== 'undefined') {
        const rsiInput = {
          values: closes,
          period: config.rsiPeriod
        };
        marketData.indicators.rsi = window.technicalIndicators.RSI.calculate(rsiInput);
      } else {
        console.error('Biblioteca technicalIndicators não carregada.');
        marketData.indicators.rsi = [];
      }
      
      // Calcular MACD
      if (typeof window.technicalIndicators !== 'undefined') {
        const macdInput = {
          values: closes,
          fastPeriod: config.macdConfig.fastPeriod,
          slowPeriod: config.macdConfig.slowPeriod,
          signalPeriod: config.macdConfig.signalPeriod,
          SimpleMAOscillator: config.macdConfig.SimpleMAOscillator,
          SimpleMASignal: config.macdConfig.SimpleMASignal
        };
        const macdResults = window.technicalIndicators.MACD.calculate(macdInput);
        // Pegar o último valor do MACD
        marketData.indicators.macd = macdResults.length > 0 ? macdResults[macdResults.length - 1] : {macd: 0, signal: 0, histogram: 0};
      } else {
        console.error('Biblioteca technicalIndicators não carregada.');
        marketData.indicators.macd = {macd: 0, signal: 0, histogram: 0};
      }
      
      // Calcular Bollinger Bands
      if (typeof window.technicalIndicators !== 'undefined') {
        const bbInput = {
          values: closes,
          period: config.bollingerPeriod,
          stdDev: config.bollingerDeviation
        };
        const bbResults = window.technicalIndicators.BollingerBands.calculate(bbInput);
        marketData.indicators.bollinger = bbResults;
      } else {
        marketData.indicators.bollinger = {upper: [], middle: [], lower: []};
      }
      
      // Calcular Stochastic Oscillator
      if (typeof window.technicalIndicators !== 'undefined') {
        const stochInput = {
          high: highs,
          low: lows,
          close: closes,
          period: config.stochasticPeriod,
          signalPeriod: config.stochasticSignalPeriod
        };
        const stochResults = window.technicalIndicators.Stochastic.calculate(stochInput);
        marketData.indicators.stochastic = stochResults;
      } else {
        marketData.indicators.stochastic = {k: [], d: []};
      }
      
      // Calcular Volume
      marketData.indicators.volume = volumes;
      
      // Calcular ADX
      if (typeof window.technicalIndicators !== 'undefined') {
        const adxInput = {
          high: highs,
          low: lows,
          close: closes,
          period: config.adxPeriod
        };
        const adxResults = window.technicalIndicators.ADX.calculate(adxInput);
        marketData.indicators.adx = adxResults;
      } else {
        marketData.indicators.adx = [];
      }
      
      // Calcular ATR
      if (typeof window.technicalIndicators !== 'undefined') {
        const atrInput = {
          high: highs,
          low: lows,
          close: closes,
          period: config.atrPeriod
        };
        const atrResults = window.technicalIndicators.ATR.calculate(atrInput);
        marketData.indicators.atr = atrResults;
      } else {
        marketData.indicators.atr = [];
      }
      
      // Calcular OBV (On Balance Volume)
      if (typeof window.technicalIndicators !== 'undefined') {
        const obvInput = {
          close: closes,
          volume: volumes
        };
        const obvResults = window.technicalIndicators.OBV.calculate(obvInput);
        marketData.indicators.obv = obvResults;
      } else {
        marketData.indicators.obv = [];
      }
      
      // Calcular Fibonacci Retracement
      if (closes.length > 0) {
        const high = Math.max(...closes);
        const low = Math.min(...closes);
        const diff = high - low;
        
        marketData.indicators.fibRetracement = {
          0: high,
          0.236: high - diff * 0.236,
          0.382: high - diff * 0.382,
          0.5: high - diff * 0.5,
          0.618: high - diff * 0.618,
          0.786: high - diff * 0.786,
          1: low
        };
      }
    }
    
    // Identificar padrões gráficos (simplificado)
    function identifyPatterns() {
      // Em uma implementação real, isso seria muito mais complexo
      marketData.patterns = [];
      
      // Selecionar aleatoriamente 3 padrões para demonstração
      const selectedPatterns = [];
      const usedIndices = new Set();
      
      while (selectedPatterns.length < 3 && selectedPatterns.length < chartPatterns.length) {
        const randomIndex = Math.floor(Math.random() * chartPatterns.length);
        if (!usedIndices.has(randomIndex)) {
          usedIndices.add(randomIndex);
          selectedPatterns.push({
            ...chartPatterns[randomIndex],
            target: marketData.klines[marketData.klines.length - 1].close * (1 + (Math.random() * 0.1 - 0.05)),
            duration: `${Math.floor(Math.random() * 24) + 1} horas`
          });
        }
      }
      
      marketData.patterns = selectedPatterns;
    }
    
    // Identificar suportes e resistências
    function identifySupportResistance() {
      const prices = marketData.klines.map(k => k.close);
      const period = Math.min(config.supportResistancePeriod, prices.length);
      
      // Encontrar mínimos e máximos locais
      const supports = [];
      const resistances = [];
      
      for (let i = 1; i < prices.length - 1; i++) {
        if (prices[i] < prices[i - 1] && prices[i] < prices[i + 1]) {
          supports.push({
            price: prices[i],
            strength: Math.random() > 0.5 ? "Forte" : "Muito Forte"
          });
        }
        
        if (prices[i] > prices[i - 1] && prices[i] > prices[i + 1]) {
          resistances.push({
            price: prices[i],
            strength: Math.random() > 0.5 ? "Forte" : "Muito Forte"
          });
        }
      }
      
      // Ordenar e selecionar os mais fortes
      marketData.supportLevels = supports
        .sort((a, b) => a.price - b.price)
        .slice(0, 4);
        
      marketData.resistanceLevels = resistances
        .sort((a, b) => b.price - a.price)
        .slice(0, 4);
    }
    
    // Gerar sinais de trading
    function generateSignals() {
      marketData.signals = [];
      
      const lastClose = marketData.klines[marketData.klines.length - 1].close;
      let signalStrength = 0;
      let factors = [];
      let trendDirection = "Neutro";
      
      // Sinal de compra baseado em RSI
      if (marketData.indicators.rsi.length > 0) {
        const lastRSI = marketData.indicators.rsi[marketData.indicators.rsi.length - 1];
        if (lastRSI < 30) {
          signalStrength += 25;
          factors.push("RSI Oversold");
        }
        
        // Sinal de venda baseado em RSI
        if (lastRSI > 70) {
          signalStrength -= 25;
          factors.push("RSI Overbought");
        }
      }
      
      // Sinal baseado em Bollinger Bands
      if (marketData.indicators.bollinger.lower.length > 0) {
        const lastLower = marketData.indicators.bollinger.lower[marketData.indicators.bollinger.lower.length - 1];
        if (lastClose < lastLower) {
          signalStrength += 20;
          factors.push("Preço abaixo da Banda Inferior");
        }
      }
      
      if (marketData.indicators.bollinger.upper.length > 0) {
        const lastUpper = marketData.indicators.bollinger.upper[marketData.indicators.bollinger.upper.length - 1];
        if (lastClose > lastUpper) {
          signalStrength -= 20;
          factors.push("Preço acima da Banda Superior");
        }
      }
      
      // Sinal baseado em Stochastic
      if (marketData.indicators.stochastic.k.length > 0) {
        const lastK = marketData.indicators.stochastic.k[marketData.indicators.stochastic.k.length - 1];
        const lastD = marketData.indicators.stochastic.d[marketData.indicators.stochastic.d.length - 1];
        
        if (lastK < 20 && lastD < 20) {
          signalStrength += 15;
          factors.push("Stochastic Oversold");
        }
        
        if (lastK > 80 && lastD > 80) {
          signalStrength -= 15;
          factors.push("Stochastic Overbought");
        }
      }
      
      // Sinal baseado em ADX
      if (marketData.indicators.adx.length > 0) {
        const lastADX = marketData.indicators.adx[marketData.indicators.adx.length - 1];
        if (lastADX > 25) {
          signalStrength += 10;
          factors.push("Tendência Forte (ADX > 25)");
          
          // Determinar direção da tendência
          const lastClose = marketData.klines[marketData.klines.length - 1].close;
          const prevClose = marketData.klines[marketData.klines.length - 2].close;
          trendDirection = lastClose > prevClose ? "Alta" : "Baixa";
        } else {
          signalStrength -= 5;
          factors.push("Tendência Fraca (ADX < 25)");
        }
      }
      
      // Sinal baseado em OBV
      if (marketData.indicators.obv.length > 1) {
        const lastOBV = marketData.indicators.obv[marketData.indicators.obv.length - 1];
        const prevOBV = marketData.indicators.obv[marketData.indicators.obv.length - 2];
        
        if (lastOBV > prevOBV) {
          signalStrength += 10;
          factors.push("Volume em Alta (OBV)");
        } else {
          signalStrength -= 5;
          factors.push("Volume em Baixa (OBV)");
        }
      }
      
      // Determinar sinal final
      let signalType = "neutral";
      let confidence = Math.abs(signalStrength);
      
      if (signalStrength > 30) {
        signalType = "buy";
      } else if (signalStrength < -30) {
        signalType = "sell";
      }
      
      if (signalType !== "neutral") {
        marketData.signals.push({
          type: signalType,
          symbol: config.symbol,
          confidence: Math.min(confidence, 99),
          currentPrice: lastClose,
          target: lastClose * (1 + (signalType === "buy" ? 0.05 : -0.05)),
          volume: (Math.random() * 2).toFixed(1) + "B",
          factors: factors,
          trendDirection: trendDirection
        });
      } else {
        marketData.signals.push({
          type: "neutral",
          symbol: config.symbol,
          message: "Mercado em consolidação. Aguarde sinais mais claros."
        });
      }
    }
    
    // Atualizar gráfico
    function updateChart() {
      const ctx = elements.priceChart.getContext('2d');
      
      if (config.chart) {
        config.chart.destroy();
      }
      
      // Preparar dados para candlesticks
      const candlestickData = marketData.klines.map(k => ({
        x: k.time.getTime(),
        o: k.open,
        h: k.high,
        l: k.low,
        c: k.close
      }));
      
      // Configuração do gráfico
      const chartConfig = {
        type: 'candlestick',
        data: {
          datasets: [
            {
              label: config.symbol,
              data: candlestickData,
              color: {
                up: '#10b981',
                down: '#ef4444',
                unchanged: '#94a3b8',
              }
            }
          ]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: {
              display: true,
              position: 'top',
              labels: {
                color: '#94a3b8'
              }
            },
            tooltip: {
              mode: 'index',
              intersect: false,
              position: 'nearest',
              callbacks: {
                label: function(context) {
                  const point = context.raw;
                  return `Abertura: $${point.o.toFixed(2)} | Fechamento: $${point.c.toFixed(2)}`;
                }
              }
            }
          },
          scales: {
            y: {
              grid: {
                color: 'rgba(100, 116, 139, 0.1)'
              },
              ticks: {
                color: '#94a3b8',
                callback: function(value) {
                  return '$' + value.toFixed(2);
                }
              }
            },
            x: {
              type: 'time',
              time: {
                unit: 'minute',
                displayFormats: {
                  minute: 'HH:mm'
                }
              },
              grid: {
                color: 'rgba(100, 116, 139, 0.1)'
              },
              ticks: {
                color: '#94a3b8',
                maxRotation: 0,
                autoSkip: true,
                maxTicksLimit: 10
              }
            }
          }
        }
      };
      
      config.chart = new Chart(ctx, chartConfig);
    }
    
    // Atualizar resumo de indicadores
    function updateIndicatorsSummary() {
      elements.indicatorsSummary.innerHTML = '';
      
      // RSI
      if (marketData.indicators.rsi.length > 0) {
        const lastRSI = marketData.indicators.rsi[marketData.indicators.rsi.length - 1];
        const rsiStatus = lastRSI < 30 ? 'Oversold' : lastRSI > 70 ? 'Overbought' : 'Neutral';
        const rsiClass = lastRSI < 30 ? 'indicator-positive' : lastRSI > 70 ? 'indicator-negative' : 'indicator-neutral';
        
        const rsiCard = document.createElement('div');
        rsiCard.className = 'indicator-card';
        rsiCard.innerHTML = `
          <div class="indicator-title">RSI (14)</div>
          <div class="indicator-value ${rsiClass}">${lastRSI.toFixed(2)}</div>
          <div class="indicator-description">${rsiStatus}</div>
        `;
        elements.indicatorsSummary.appendChild(rsiCard);
      }
      
      // MACD
      if (marketData.indicators.macd) {
        const macdStatus = marketData.indicators.macd.histogram > 0 ? 'Bullish' : 'Bearish';
        const macdClass = marketData.indicators.macd.histogram > 0 ? 'indicator-positive' : 'indicator-negative';
        
        const macdCard = document.createElement('div');
        macdCard.className = 'indicator-card';
        macdCard.innerHTML = `
          <div class="indicator-title">MACD</div>
          <div class="indicator-value ${macdClass}">${marketData.indicators.macd.histogram.toFixed(4)}</div>
          <div class="indicator-description">${macdStatus}</div>
        `;
        elements.indicatorsSummary.appendChild(macdCard);
      }
      
      // Bollinger Bands
      if (marketData.indicators.bollinger.lower.length > 0) {
        const lastClose = marketData.klines[marketData.klines.length - 1].close;
        const lastUpper = marketData.indicators.bollinger.upper[marketData.indicators.bollinger.upper.length - 1];
        const lastLower = marketData.indicators.bollinger.lower[marketData.indicators.bollinger.lower.length - 1];
        
        let bbStatus = 'Neutral';
        let bbClass = 'indicator-neutral';
        
        if (lastClose < lastLower) {
          bbStatus = 'Oversold';
          bbClass = 'indicator-positive';
        } else if (lastClose > lastUpper) {
          bbStatus = 'Overbought';
          bbClass = 'indicator-negative';
        }
        
        const bbCard = document.createElement('div');
        bbCard.className = 'indicator-card';
        bbCard.innerHTML = `
          <div class="indicator-title">Bollinger Bands</div>
          <div class="indicator-value ${bbClass}">${bbStatus}</div>
          <div class="indicator-description">Bandwidth: ${((lastUpper - lastLower) / lastClose * 100).toFixed(2)}%</div>
        `;
        elements.indicatorsSummary.appendChild(bbCard);
      }
      
      // Stochastic
      if (marketData.indicators.stochastic.k.length > 0) {
        const lastK = marketData.indicators.stochastic.k[marketData.indicators.stochastic.k.length - 1];
        const lastD = marketData.indicators.stochastic.d[marketData.indicators.stochastic.d.length - 1];
        
        const stochStatus = lastK < 20 && lastD < 20 ? 'Oversold' : lastK > 80 && lastD > 80 ? 'Overbought' : 'Neutral';
        const stochClass = lastK < 20 && lastD < 20 ? 'indicator-positive' : lastK > 80 && lastD > 80 ? 'indicator-negative' : 'indicator-neutral';
        
        const stochCard = document.createElement('div');
        stochCard.className = 'indicator-card';
        stochCard.innerHTML = `
          <div class="indicator-title">Stochastic</div>
          <div class="indicator-value ${stochClass}">K: ${lastK.toFixed(2)} | D: ${lastD.toFixed(2)}</div>
          <div class="indicator-description">${stochStatus}</div>
        `;
        elements.indicatorsSummary.appendChild(stochCard);
      }
      
      // ADX
      if (marketData.indicators.adx.length > 0) {
        const lastADX = marketData.indicators.adx[marketData.indicators.adx.length - 1];
        const adxStatus = lastADX > 25 ? 'Tendência Forte' : 'Tendência Fraca';
        const adxClass = lastADX > 25 ? 'indicator-positive' : 'indicator-neutral';
        
        const adxCard = document.createElement('div');
        adxCard.className = 'indicator-card';
        adxCard.innerHTML = `
          <div class="indicator-title">ADX (14)</div>
          <div class="indicator-value ${adxClass}">${lastADX.toFixed(2)}</div>
          <div class="indicator-description">${adxStatus}</div>
        `;
        elements.indicatorsSummary.appendChild(adxCard);
      }
      
      // ATR
      if (marketData.indicators.atr.length > 0) {
        const lastATR = marketData.indicators.atr[marketData.indicators.atr.length - 1];
        const atrStatus = lastATR > 100 ? 'Alta Volatilidade' : 'Baixa Volatilidade';
        const atrClass = lastATR > 100 ? 'indicator-negative' : 'indicator-neutral';
        
        const atrCard = document.createElement('div');
        atrCard.className = 'indicator-card';
        atrCard.innerHTML = `
          <div class="indicator-title">ATR (14)</div>
          <div class="indicator-value ${atrClass}">${lastATR.toFixed(2)}</div>
          <div class="indicator-description">${atrStatus}</div>
        `;
        elements.indicatorsSummary.appendChild(atrCard);
      }
      
      // OBV
      if (marketData.indicators.obv.length > 1) {
        const lastOBV = marketData.indicators.obv[marketData.indicators.obv.length - 1];
        const prevOBV = marketData.indicators.obv[marketData.indicators.obv.length - 2];
        const obvStatus = lastOBV > prevOBV ? 'Volume em Alta' : 'Volume em Baixa';
        const obvClass = lastOBV > prevOBV ? 'indicator-positive' : 'indicator-negative';
        
        const obvCard = document.createElement('div');
        obvCard.className = 'indicator-card';
        obvCard.innerHTML = `
          <div class="indicator-title">OBV</div>
          <div class="indicator-value ${obvClass}">${(lastOBV / 1000000).toFixed(2)}M</div>
          <div class="indicator-description">${obvStatus}</div>
        `;
        elements.indicatorsSummary.appendChild(obvCard);
      }
    }
    
    // Atualizar elementos da UI
    function updateUI() {
      // Atualizar símbolo
      elements.chartSymbol.textContent = config.symbol.replace('USDT', '/USDT');
      
      // Atualizar suportes
      elements.supportList.innerHTML = '';
      marketData.supportLevels.forEach(level => {
        const li = document.createElement('li');
        li.innerHTML = `
          <span>$${level.price.toFixed(2)}</span>
          <span class="stat-badge ${level.strength === "Muito Forte" ? 'stat-positive' : 'stat-neutral'}">
            ${level.strength}
          </span>
        `;
        elements.supportList.appendChild(li);
      });
      
      // Atualizar resistências
      elements.resistanceList.innerHTML = '';
      marketData.resistanceLevels.forEach(level => {
        const li = document.createElement('li');
        li.innerHTML = `
          <span>$${level.price.toFixed(2)}</span>
          <span class="stat-badge ${level.strength === "Muito Forte" ? 'stat-negative' : 'stat-neutral'}">
            ${level.strength}
          </span>
        `;
        elements.resistanceList.appendChild(li);
      });
      
      // Atualizar padrões gráficos
      elements.patternsGrid.innerHTML = '';
      marketData.patterns.forEach(pattern => {
        const patternCard = document.createElement('div');
        patternCard.className = 'signal-card';
        
        patternCard.innerHTML = `
          <div class="signal-header">
            <div class="signal-type ${pattern.type === "continuation" ? 'signal-buy' : 'signal-sell'}">
              ${pattern.type === "continuation" ? 'Padrão de Continuação' : 'Padrão de Reversão'}
            </div>
            <div class="signal-time">${config.symbol.replace('USDT', '/USDT')} | ${config.timeframe}</div>
          </div>
          <div class="signal-body">
            <div class="signal-info">
              <div class="info-item">
                <span class="info-label">Tipo de Padrão</span>
                <span class="info-value">${pattern.name}</span>
              </div>
              <div class="info-item">
                <span class="info-label">Confiança</span>
                <span class="info-value">${pattern.confidence}%</span>
              </div>
              <div class="info-item">
                <span class="info-label">Alvo Teórico</span>
                <span class="info-value">$${pattern.target.toFixed(2)}</span>
              </div>
              <div class="info-item">
                <span class="info-label">Duração</span>
                <span class="info-value">${pattern.duration}</span>
              </div>
            </div>
            
            <div class="pattern-container">
              <div class="pattern-title">
                <i class="${pattern.icon}"></i>
                ${pattern.name}
              </div>
              <p class="pattern-description">
                ${pattern.description}
              </p>
              <div class="pattern-badge ${pattern.type === "continuation" ? 'continuation' : 'reversal'}">
                ${pattern.type === "continuation" ? 'Continuação de Tendência' : 'Reversão de Tendência'}
              </div>
            </div>
          </div>
        `;
        
        elements.patternsGrid.appendChild(patternCard);
      });
      
      // Gerar sinais
      generateSignals();
      
      // Atualizar sinais em tempo real
      elements.signalsGrid.innerHTML = '';
      marketData.signals.forEach(signal => {
        if (signal.type === "neutral") {
          const neutralCard = document.createElement('div');
          neutralCard.className = 'signal-card';
          neutralCard.innerHTML = `
            <div class="signal-header">
              <div class="signal-type">SINAL NEUTRO</div>
            </div>
            <div class="signal-body">
              <div class="pattern-container">
                <div class="pattern-title">
                  <i class="fas fa-info-circle"></i>
                  Sem sinais fortes
                </div>
                <p>${signal.message}</p>
              </div>
            </div>
          `;
          elements.signalsGrid.appendChild(neutralCard);
        } else {
          const signalCard = document.createElement('div');
          signalCard.className = `signal-card ${signal.type}`;
          
          signalCard.innerHTML = `
            <div class="signal-header">
              <div class="signal-type ${signal.type === "buy" ? "signal-buy" : "signal-sell"}">
                ${signal.type === "buy" ? "COMPRA" : "VENDA"}
              </div>
              <div class="signal-time">${new Date().toLocaleTimeString()} | ${signal.symbol.replace('USDT', '/USDT')}</div>
            </div>
            <div class="signal-body">
              <div class="signal-info">
                <div class="info-item">
                  <span class="info-label">Preço Atual</span>
                  <span class="info-value">$${signal.currentPrice.toFixed(2)}</span>
                </div>
                <div class="info-item">
                  <span class="info-label">Confiança</span>
                  <span class="info-value">${signal.confidence}%</span>
                </div>
                <div class="info-item">
                  <span class="info-label">Volume</span>
                  <span class="info-value">${signal.volume}</span>
                </div>
                <div class="info-item">
                  <span class="info-label">Alvo</span>
                  <span class="info-value">$${signal.target.toFixed(2)}</span>
                </div>
                <div class="info-item">
                  <span class="info-label">Tendência</span>
                  <span class="info-value">
                    <span class="trend-direction ${signal.trendDirection === "Alta" ? 'trend-up' : signal.trendDirection === "Baixa" ? 'trend-down' : 'trend-neutral'}">
                      ${signal.trendDirection}
                    </span>
                  </span>
                </div>
              </div>
              
              <div class="pattern-container">
                <div class="pattern-title">
                  <i class="fas fa-project-diagram"></i>
                  Fatores de Confirmação
                </div>
                <div class="convergence-items" style="margin-top: 10px; display: flex; flex-wrap: wrap; gap: 5px;">
                  ${signal.factors.map(factor => 
                    `<div class="pattern-badge ${
                      factor.includes('Oversold') || factor.includes('Bullish') || factor.includes('Alta') ? 'stat-positive' : 
                      factor.includes('Overbought') || factor.includes('Bearish') || factor.includes('Baixa') ? 'stat-negative' : ''
                    }">${factor}</div>`
                  ).join('')}
                </div>
              </div>
            </div>
          `;
          
          elements.signalsGrid.appendChild(signalCard);
          
          // Adicionar notificação
          if (signal.confidence > 75) {
            showNotification(
              signal.type, 
              signal.symbol.replace('USDT', '/USDT'), 
              `Sinal de ${signal.type === "buy" ? "compra" : "venda"} com ${signal.confidence}% de confiança`
            );
          }
        }
      });
      
      // Atualizar resumo de indicadores
      updateIndicatorsSummary();
      
      // Atualizar precisão
      const accuracy = 75 + Math.random() * 10;
      elements.accuracyBadge.textContent = `Precisão: ${accuracy.toFixed(1)}%`;
    }
    
    // Mostrar notificação
    function showNotification(type, asset, message) {
      const notification = document.createElement('div');
      notification.className = `notification-item ${type}`;
      
      const now = new Date();
      const timeStr = now.toLocaleTimeString();
      
      notification.innerHTML = `
        <strong>${type === 'buy' ? 'COMPRA' : type === 'sell' ? 'VENDA' : 'ALERTA'}: ${asset}</strong>
        <p>${message}</p>
        <div class="notification-time">${timeStr}</div>
      `;
      
      elements.notificationList.prepend(notification);
      
      // Limitar a quantidade de notificações
      if (elements.notificationList.children.length > 10) {
        elements.notificationList.removeChild(elements.notificationList.lastChild);
      }
      
      // Atualizar badge de notificação
      const badge = document.querySelector('.notification-badge');
      badge.textContent = parseInt(badge.textContent) + 1;
    }
    
    // Inicializar a página
    document.addEventListener('DOMContentLoaded', () => {
      // Carregar dados iniciais
      fetchMarketData();
      
      // Configurar botão de toggle
      let active = true;
      
      elements.toggleBot.addEventListener('click', () => {
        active = !active;
        
        if (active) {
          elements.statusIndicator.classList.add('active');
          elements.statusText.textContent = 'Sistema Ativo';
          elements.toggleBot.innerHTML = '<i class="fas fa-power-off"></i> Parar Sistema';
          elements.toggleBot.classList.add('btn-stop');
          fetchMarketData();
        } else {
          elements.statusIndicator.classList.remove('active');
          elements.statusText.textContent = 'Sistema Parado';
          elements.toggleBot.innerHTML = '<i class="fas fa-power-off"></i> Iniciar Sistema';
          elements.toggleBot.classList.remove('btn-stop');
        }
      });
      
      // Atualizar timeframe
      elements.timeframeSelector.addEventListener('click', (e) => {
        if (e.target.classList.contains('timeframe-btn')) {
          // Remover classe ativa de todos os botões
          const buttons = elements.timeframeSelector.querySelectorAll('.timeframe-btn');
          buttons.forEach(btn => btn.classList.remove('active'));
          
          // Adicionar classe ativa ao botão clicado
          e.target.classList.add('active');
          
          // Atualizar configuração
          config.timeframe = e.target.dataset.tf;
          
          // Recarregar dados
          fetchMarketData();
        }
      });
      
      // Atualizar símbolo
      elements.symbolSelector.addEventListener('change', (e) => {
        config.symbol = e.target.value;
        fetchMarketData();
      });
      
      // Atualizar notificações
      elements.refreshNotifications.addEventListener('click', () => {
        // Simular nova notificação
        const events = [
          { type: 'buy', asset: 'BTC/USDT', message: 'Rompeu resistência importante' },
          { type: 'sell', asset: 'ETH/USDT', message: 'Divergência de RSI em timeframe H4' },
          { type: '', asset: 'XRP/USDT', message: 'Formação de triângulo simétrico' },
          { type: 'buy', asset: 'SOL/USDT', message: 'Teste de suporte bem-sucedido' },
          { type: 'sell', asset: 'ADA/USDT', message: 'Padrão cabeça e ombros confirmado' }
        ];
        
        const event = events[Math.floor(Math.random() * events.length)];
        showNotification(event.type, event.asset, event.message);
      });
      
      // Alternar entre gráficos
      elements.tabs.forEach(tab => {
        tab.addEventListener('click', () => {
          elements.tabs.forEach(t => t.classList.remove('active'));
          tab.classList.add('active');
          
          // Em uma implementação real, mudaríamos o gráfico aqui
          // Para simplificar, vamos apenas recarregar os dados
          fetchMarketData();
        });
      });
      
      // Atualizar dados a cada minuto
      setInterval(() => {
        if (active) {
          fetchMarketData();
        }
      }, 60000);
    });
  </script>
</body>
</html>